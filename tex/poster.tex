%!LW recipe = latexmk (PdfLaTeX)
\documentclass[a1, portrait]{a0poster} % A0 縦向き

% --- 数学・記号系 ---
\usepackage{amsmath, amsthm, mathtools}
\usepackage{amssymb}  %（amsfontsを自動で含む)

% --- 段落設定 ---
\usepackage{multicol}

% --- 日本語・フォント設定 ---
\usepackage[whole]{bxcjkjatype}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% --- 以下 lstlisting の設定 ---
% --- ソースコード表示 ---
\usepackage{listings}
\usepackage{zi4}  % Leanコード表示用, 任意

% 色の設定
\usepackage{xcolor}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red

% --- lstlistingの設定の読み込み ---
\def\lstlanguagefiles{lstlean.tex}

% set default language
\lstset{
  language=lean,
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  columns=fullflexible,
  keepspaces=true,
  mathescape=true
  % xleftmargin=0.15em,
  % xrightmargin=0.15em,
  % tabsize=2,
  % lineskip=0pt,
  % aboveskip=0.2em,
  % belowskip=0em
}

% --- 以上 lstlisting の設定 ---

% --- フォントサイズの定義 (A1ポスター用) ---
% A0用の値を概ね0.7〜0.8倍に設定しています
\renewcommand{\tiny}{\fontsize{7}{9}\selectfont}
\renewcommand{\scriptsize}{\fontsize{9}{11}\selectfont}
\renewcommand{\footnotesize}{\fontsize{11}{14}\selectfont}
\renewcommand{\small}{\fontsize{14}{17}\selectfont}
\renewcommand{\normalsize}{\fontsize{17}{21}\selectfont}
\renewcommand{\large}{\fontsize{21}{26}\selectfont}  
\renewcommand{\Large}{\fontsize{25}{31}\selectfont}
\renewcommand{\LARGE}{\fontsize{30}{38}\selectfont}
\renewcommand{\huge}{\fontsize{36}{45}\selectfont}
\renewcommand{\Huge}{\fontsize{44}{55}\selectfont}
\renewcommand{\veryHuge}{\fontsize{52}{65}\selectfont}
\renewcommand{\VeryHuge}{\fontsize{63}{79}\selectfont}
\renewcommand{\VERYHuge}{\fontsize{75}{94}\selectfont}

\theoremstyle{definition}
\newtheorem{theorem}{定理}[section]
\newtheorem{lemma}{補題}[section]
\newtheorem{prop}{命題}[section]
\newtheorem{definition}{定義}[section]
\newtheorem{corollary}{系}[section]


\title{\(Lean\) による \(GL(2, \mathbb{Q})\) の有限位数の決定}
\author{氏名 ： 森下~善~(北海道大学理学部数学科) \quad 指導教員 ： 松下~大介}
\date{~}

% 線の太さを指定（例: 0.4pt が標準的な細線）
\setlength{\columnseprule}{0.4pt}
\setlength{\columnsep}{30pt}

\begin{document}
  
% 表紙の作成
\maketitle

\begin{multicols}{3}
  
\section{はじめに}

  本稿では, 有理数体上の2次一般線型群 \(GL(2, \mathbb{Q})\) の有限位数行列の分類を
  証明支援系 \(Lean\) を用いて形式化していく.

  具体的には, \(GL(2, \mathbb{Q})\) の有限位数元の位数は \(1, 2, 3, 4, 6\) に限定されることを
  最小多項式と円分多項式の関係, 次数の制約から
  
  方針は, 最小多項式が円分多項式で表せることを示し, 次数の制約から, 位数が \(1, 2, 3, 4, 6\) のみ
  であることを

\section{有限位数の決定}

\begin{definition}[有限位数元]~\

  \(G\) を群とする.

  \(g \in G\) が \(G\) の有限位数元であるとは, \(g^n = 1\)(単位元) を満たすような
  正の整数 \(n\) が存在することである.

  また,このような \(n\) のうち, 最小のものを \(g\) の位数という.

\end{definition}

以下, \(M\) を \(GL(2, \mathbb{Q})\) の有限位数元, \(n\) をその位数とする.

\begin{definition}[最小多項式]~
  最高次数係数が1の多項式 \(m_M(x)\) のうち,

  \(m_M(M) = O\) となるもので次数が最小のものを \(M\) の最小多項式という.

\end{definition}


\begin{lemma}

  最小多項式の次数は2以下.

  \begin{proof}
    最小多項式が固有多項式を割り切り, 固有多項式の次数が2であることから示せる.
  \end{proof}

\end{lemma}


\begin{lemma}
  
  最小多項式 \(m_M(x)\) は, \(X^n - 1\) を割り切る.

  \begin{proof}
    \(X^n - 1\) がMを根に持つことから示せる.
  \end{proof}

\end{lemma}


\begin{definition}[円分多項式]~\

  複素数平面における1の原始n乗根 \(\zeta_n^k = e^{2ki\pi/n}\)(\(1 \leq k \leq n\) かつ \(gcd(k, n) = 1\))
  のすべてを解に持つ多項式,
  \[\Phi_n(x) := \prod_{\substack{1 \leq k \leq n\\ gcd(k, n) = 1}} (x - e^{2ki\pi / n})\]

  を第n円分多項式という.

\end{definition}


\begin{lemma}
  
  \(x^n - 1 = \prod_{i \mid n} \Phi_i(x)\).

  \begin{proof}
    \(x^n - 1 = \prod_{1 \leq k \leq n} (x - \zeta_n^k)\) で,
    \(i = \frac{n}{gcd(k, n)}\) とおくと, \(\zeta_n^k\) は1の原始i乗根.

    kが1からnまで動くとき, 各kに対してiはnの約数.
  \end{proof}

\end{lemma}


\begin{lemma}

  最小多項式のモニックな既約因子は第i(nの約数)円分多項式と一致する.

  \begin{lstlisting}
    lemma normalizedfactor_eq_cyclotomic (h : IsOfFinOrder M.val) (h' : n = orderOf M.val)
    (f : ℚ[X]) (fmon : Monic f) (firr : Irreducible f) (fdvd : f ∣ minpoly ℚ M.val) :
    ∃ i ∈ n.divisors, f = Φ i := by
  have npos : 0 < n := by simp only [h', orderOf_pos_iff, h]
  have hdvd : f ∣ X^n - 1 := dvd_trans fdvd (minpoly_dvd_X_pow_sub_one M h')
  rw [← prod_cyclotomic_eq_X_pow_sub_one npos] at hdvd
  have h₁ : ∃ i ∈ n.divisors, f ∣ Φ i := by
    rw [← (prime firr).dvd_finset_prod_iff]; exact hdvd
  obtain ⟨i, imem, hdvd'⟩ := h₁
  have h₂ : Irreducible (Φ i) :=
    cyclotomic.irreducible_rat (pos_of_mem_divisors imem)
  have h₃ : Associated f (Φ i) := associated_of_dvd firr h₂ hdvd'
  use i, imem
  rcases h₃ with ⟨u, feq⟩
  have ueq : u.val = 1 := by
    have h1 : Monic (Φ i) := cyclotomic.monic i ℚ
    rw [← feq] at h1
    have h2 : Monic u.val := Monic.of_mul_monic_left fmon h1
    rw [← Monic.isUnit_iff h2]; exact u.isUnit
  rw [← feq, ueq, mul_one]  \end{lstlisting}

  \begin{proof}

    fを \(m_M(x)\) のモニックな既約因子とする.
    補題2.2, 2.4より, \(f \mid m_M(X) \wedge m_M(x) \mid X^n - 1 \wedge X^n - 1 = \prod_{i \mid n} \Phi_i(x)\).
    よって, \(f \mid \prod_{i \mid n} \Phi_i(x)\).
    多項式環 \(\mathbb{Q}[X]\) はUFD(一意分解整域), fが既約であることから, あるnの約数iについて \(f \mid \Phi_i(x)\).
    \(f, \Phi_i(x)\) は既約より, ある単元uを用いて, \(\Phi_i(x) = f * u\) と表せる.
    \(f, \Phi_i(x)\) はモニックより, \(u = 1\) が示される.    
  \end{proof}

\end{lemma}


\begin{definition}[オイラーのトーシェント関数]~\
  
  正の整数 \(n\) について, \(n\) 以下の正の整数のうち, \(n\) と互いに素なものの個数を
  \(\phi(n)\) と書き, これをオイラーのトーシェント関数という. 
  \[\phi(n) := \# \{a \mid 1 \leq a \leq n, gcd(a, n) = 1\}\]

\end{definition}


\begin{lemma}

  円分多項式の次数は, オイラーのトーシェント関数と等しい.

  \begin{proof}
    円分多項式の定義から明らか.
  \end{proof}

\end{lemma}


\begin{lemma}

  \(\phi(n) \leq 2 \Leftrightarrow n = 1, 2, 3, 4, 6\).

  \begin{proof}
    
    \(p_i\) (\(1 \leq i \leq n\)) を素数, \(n = \prod_{1 \leq i \leq n} p_i^{n_i}\) と素因数分解できるとする.

    このとき, \(\phi(n) = \phi(\prod_{1 \leq i \leq n} p_i^{n_i}) = \prod_{1 \leq i \leq n} \phi(p_i^{n_i})
    = \prod_{1 \leq i \leq n} p_i^{n_i-1}(p_i-1)\).

    \(p_i \geq 5\) とすると, \(\phi(n) \geq 4\) となるため,不適.
    よって, nは2と3以外の素因数をもたない. \(n = 2^a3^b (a, b \geq 0)\) とおくと,
    \(\phi(n) = 2^a3^{b-1} \leq 2 \Leftrightarrow (a, b) = (0, 0), (1, 0), (0, 1), (2, 0), (1, 1)\).
    したがって, \(n = 1, 2, 3, 4, 6\).
  \end{proof}

\end{lemma}

\begin{lemma}

  最小多項式のモニックな既約因子は
  \[ \Phi_1(x), \Phi_2(x), \Phi_3(x), \Phi_4(x), \Phi_6(x)\] に限る.

\end{lemma}


\begin{lemma}

  \(M\) の最小多項式 \(m_M(x)\) は
  \[ \Phi_1(x), \Phi_2(x), \Phi_3(x), \Phi_4(x), \Phi_6(x), \Phi_1(x)\Phi_2(x)\] に限る.

  \begin{lstlisting}
    lemma minpoly_class (h : IsOfFinOrder M.val) (h' : n = orderOf M.val) :
    minpoly ℚ M.val ∈ ({Φ 1, Φ 2, Φ 3, Φ 4, Φ 6, (Φ 1)*(Φ 2)} : Finset ℚ[X]) := by
  obtain ⟨f, fmon, firr, fdvd⟩ := exist_normalizefactor M
  have h₀ := normalizedfactor_class M h h' f fmon firr fdvd
  rcases fdvd with ⟨g, hg⟩
  have h₁ : Monic (minpoly ℚ M.val) := monic (isIntegral M.val)
  have h₂ : Monic g := by
    rw [hg] at h₁
    apply Monic.of_mul_monic_left fmon h₁
  have h₃ : (minpoly ℚ M.val).natDegree = f.natDegree + g.natDegree := by
    rw [hg]
    apply natDegree_mul
    · exact Monic.ne_zero fmon
    · exact Monic.ne_zero h₂
  have h₄ : (minpoly ℚ M.val).natDegree ∈ ({1, 2} : Finset ℕ) := by
    have h₅ := minpoly_deg_le_two M
    interval_cases hdeg : (minpoly ℚ M.val).natDegree
    · contrapose! hdeg
      exact ne_of_gt (natDegree_pos (isIntegral M.val))
    · decide
    · decide
  rw [mem_insert, mem_singleton] at h₄
  rcases h₄ with (h4 | h4)
  · have gdeg : g.natDegree = 0 := by
      have hactor_deg : 1 ≤ f.natDegree := by
        simp only [mem_insert, mem_singleton] at h₀
        rcases h₀ with (h | h | h | h | h) <;> rw [h]
        · have h1 : (Φ 1).natDegree = 1 := by
            rw [cyclotomic_one]; exact natDegree_X_sub_C 1
          rw [h1]
        · have h1 : (Φ 2).natDegree = 1 := by
            rw [cyclotomic_two]; exact natDegree_X_add_C 1
          rw [h1]
        · have h1 : (Φ 3).natDegree = 2 := by
            rw [cyclotomic_three]; compute_degree; decide
          linarith [h1]
        · have h1 : (Φ 4).natDegree = 2 := by
            rw [cyclotomic_four]; exact natDegree_X_pow_add_C
          linarith [h1]
        · have h1 : (Φ 6).natDegree = 2 := by
            rw [cyclotomic_six]; compute_degree; decide
          linarith [h1]
      linarith
    have geq : g = 1 := eq_one_of_monic_natDegree_zero h₂ gdeg
    have hf : minpoly ℚ M.val = f := by rw [geq, mul_one] at hg; exact hg
    simp only [← hf, mem_insert, mem_singleton] at h₀
    rcases h₀ with (h | h | h | h | h) <;> simp [h]
  · simp only [mem_insert, mem_singleton] at h₀
    rcases h₀ with (h1 | h1 | h | h | h)
    · have fdeg : f.natDegree = 1 := by rw [h1, cyclotomic_one]; compute_degree; decide
      have gdeg : g.natDegree = 1 := by rw [h4, fdeg] at h₃; linarith
      simp only [mem_insert, mem_singleton]; right; right; right; right; right
      rw [hg, h1]
      have girr : Irreducible g := by
        rw [← degree_eq_iff_natDegree_eq_of_pos (by decide), cast_one] at gdeg
        exact irreducible_of_degree_eq_one  gdeg
      obtain h5 := g_class M h h' f g fmon girr hg
      simp only [mem_insert, mem_singleton] at h5
      rcases h5 with (h6 | h6 | h6 | h6 | h6)
      · rw [h6, ← h1] at hg
        have h₅ : Squarefree (minpoly ℚ M.val) := by
          have h₇ : Squarefree (X^n - 1 : ℚ[X]) := by
            apply Separable.squarefree
            apply separable_X_pow_sub_C
            rw [ne_eq, cast_eq_zero]
            intro nh
            have hn : 0 < n := by simp only [h', orderOf_pos_iff, h]
            linarith; decide
          apply Squarefree.squarefree_of_dvd (minpoly_dvd_X_pow_sub_one M h') h₇
        rw [squarefree_iff_no_irreducibles (ne_zero_of_finite ℚ M.val)] at h₅
        specialize h₅ f firr; rw [hg] at h₅; contrapose h₅; exact dvd_refl (f * f)
      · rw [h6, cyclotomic_one, cyclotomic_two]
      · rw [h6] at gdeg
        have : (X^2 + X + 1 : ℚ[X]).natDegree = 2 := by compute_degree; decide
        rw [cyclotomic_three, this] at gdeg; contradiction
      · rw [h6] at gdeg
        have : (X^2 + 1 : ℚ[X]).natDegree = 2 := by compute_degree; decide
        rw [cyclotomic_four, this] at gdeg; contradiction
      · rw [h6] at gdeg
        have : (X^2 - X + 1 : ℚ[X]).natDegree = 2 := by compute_degree; decide
        rw [cyclotomic_six, this] at gdeg; contradiction
    · have fdeg : f.natDegree = 1 := by rw [h1, cyclotomic_two]; compute_degree; decide
      have gdeg : g.natDegree = 1 := by rw [h4, fdeg] at h₃; linarith
      simp only [mem_insert, mem_singleton]; right; right; right; right; right
      rw [hg, h1]
      have girr : Irreducible g := by
        rw [← degree_eq_iff_natDegree_eq_of_pos (by decide), cast_one] at gdeg
        exact irreducible_of_degree_eq_one  gdeg
      obtain h5 := g_class M h h' f g fmon girr hg
      simp only [mem_insert, mem_singleton] at h5
      rcases h5 with (h6 | h6 | h6 | h6 | h6)
      · rw [h6, mul_comm]
      · rw [h6, ← h1] at hg
        have h₅ : Squarefree (minpoly ℚ M.val) := by
          have h₇ : Squarefree (X^n - 1 : ℚ[X]) := by
            apply Separable.squarefree
            apply separable_X_pow_sub_C
            rw [ne_eq, cast_eq_zero]
            intro nh
            have hn : 0 < n := by simp only [h', orderOf_pos_iff, h]
            linarith; decide
          apply Squarefree.squarefree_of_dvd (minpoly_dvd_X_pow_sub_one M h') h₇
        rw [squarefree_iff_no_irreducibles (ne_zero_of_finite ℚ M.val)] at h₅
        specialize h₅ f firr; rw [hg] at h₅; contrapose h₅; exact dvd_refl (f * f)
      · rw [h6] at gdeg
        have : (X^2 + X + 1 : ℚ[X]).natDegree = 2 := by compute_degree; decide
        rw [cyclotomic_three, this] at gdeg; contradiction
      · rw [h6] at gdeg
        have : (X^2 + 1 : ℚ[X]).natDegree = 2 := by compute_degree; decide
        rw [cyclotomic_four, this] at gdeg; contradiction
      · rw [h6] at gdeg
        have : (X^2 - X + 1 : ℚ[X]).natDegree = 2 := by compute_degree; decide
        rw [cyclotomic_six, this] at gdeg; contradiction
    · have fdeg : f.natDegree = 2 := by rw [h, cyclotomic_three]; compute_degree; decide
      have gdeg : g.natDegree = 0 := by rw [h4, fdeg] at h₃; linarith
      have geq : g = 1 := eq_one_of_monic_natDegree_zero h₂ gdeg
      have hf : minpoly ℚ M.val = f := by rw [geq, mul_one] at hg; exact hg
      rw [h] at hf
      simp only [mem_insert, mem_singleton]; right; right; left; exact hf
    · have fdeg : f.natDegree = 2 := by rw [h, cyclotomic_four]; compute_degree; decide
      have gdeg : g.natDegree = 0 := by rw [h4, fdeg] at h₃; linarith
      have geq : g = 1 := eq_one_of_monic_natDegree_zero h₂ gdeg
      have hf : minpoly ℚ M.val = f := by rw [geq, mul_one] at hg; exact hg
      rw [h] at hf
      simp only [mem_insert, mem_singleton]; right; right; right; left; exact hf
    · have fdeg : f.natDegree = 2 := by rw [h, cyclotomic_six]; compute_degree; decide
      have gdeg : g.natDegree = 0 := by rw [h4, fdeg] at h₃; linarith
      have geq : g = 1 := eq_one_of_monic_natDegree_zero h₂ gdeg
      have hf : minpoly ℚ M.val = f := by rw [geq, mul_one] at hg; exact hg
      rw [h] at hf
      simp only [mem_insert, mem_singleton]; right; right; right; right; left; exact hf
  \end{lstlisting}

  \begin{proof}
    

  \end{proof}
\end{lemma}

\begin{theorem}

  \(GL(2, \mathbb{Q})\) の有限位数元が存在するならば、
  その位数は \(1, 2, 3, 4, 6\) に限る.

  \begin{proof}
    
    \(m_M(x) = \Phi_i(x) (i = 1, 2, 3, 4, 6)\) のとき, \(m_M(x)\) はMを根に持ち,
    \(\Phi_i(x)\) は原始i乗根のすべてを解に持つため, Mは原始i乗根となる.

    \(m_M(x) = \Phi_1(x)\Phi_2(x)\) のとき, Mは \(gcd(1, 2) = 2\) で, 原始2乗根となる.
  \end{proof}
\end{theorem}

\begin{theorem}
  
  \(n = 1, 2, 3, 4, 6\) それぞれに対して, 位数が \(n\) となるような
  \(GL(2, \mathbb{Q})\) の元Mが存在する.

  \begin{proof}
    
    \(\left(\begin{smallmatrix} 1 & 0 \\ 0 & 1 \end{smallmatrix} \right)\) は位数1の元,
    \(\left(\begin{smallmatrix} 1 & 0 \\ 0 & -1 \end{smallmatrix} \right)\) は位数2の元,
    \(\left(\begin{smallmatrix} 0 & -1 \\ 1 & -1 \end{smallmatrix} \right)\) は位数3の元,
    \(\left(\begin{smallmatrix} 0 & 1 \\ -1 & 0 \end{smallmatrix} \right)\) は位数4の元,
    \(\left(\begin{smallmatrix} 0 & -1 \\ 1 & 1 \end{smallmatrix} \right)\) は位数6の元.
  \end{proof}

\end{theorem}

\section{おわりに}

  すべてのコードは書ききれない。６００行にもなる。
  今回は有理数体上で考えたが、実数体、複素数と拡張していくと、
  より複雑になり、代数的構造の知識も必要になる。

\end{multicols}

\end{document}